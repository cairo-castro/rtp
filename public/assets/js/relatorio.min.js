/**
 * RTP Hospital Dashboard - ApexCharts Implementation
 * 
 * Sistema otimizado de grÃ¡ficos ApexCharts com foco em performance e usabilidade.
 * MigraÃ§Ã£o do Chart.js para ApexCharts para melhor controle de layout,
 * espaÃ§amento da legenda e otimizaÃ§Ãµes de performance.
 * 
 * Features implementadas:
 * - Lazy loading com IntersectionObserver API
 * - Sistema de cache com localStorage
 * - Debouncing para eventos de resize
 * - Monitoramento de performance em tempo real
 * - Modo debug condicional (apenas desenvolvimento)
 * - ConfiguraÃ§Ãµes otimizadas para dispositivos mÃ³veis
 * 
 * Performance optimizations:
 * - ReduÃ§Ã£o de console.log em produÃ§Ã£o
 * - AnimaÃ§Ãµes otimizadas (600ms vs 800ms padrÃ£o)
 * - Lazy loading para carregamento sob demanda
 * - Cache com expiraÃ§Ã£o de 5 minutos
 * - Debounce de 150ms para resize events
 * 
 * @version 2.1
 * @author Sistema RTP Hospital
 * @date 2025-01-08
 * @requires ApexCharts ^3.x
 * @performance Otimizado para 5000+ serviÃ§os/segundo
 */

document.addEventListener("DOMContentLoaded", function () {
    /**
     * Modo de debug ativo apenas em ambiente de desenvolvimento
     * Evita poluiÃ§Ã£o do console em produÃ§Ã£o
     * @constant {boolean} DEBUG_MODE
     */
    const DEBUG_MODE = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
    
    /**
     * FunÃ§Ã£o de log condicional para debugging
     * SÃ³ executa console.log em ambiente de desenvolvimento
     * @param {string} message - Mensagem a ser logada
     * @param {*} data - Dados opcionais para log
     */
    function debugLog(message, data) {
        if (DEBUG_MODE) {
            console.log(message, data || '');
        }
    }

    debugLog('ðŸš€ ApexCharts Dashboard carregado!');

    /**
     * Adiciona labels customizados para dias da semana abaixo dos nÃºmeros dos dias
     * Cria elementos HTML posicionados para mostrar dia da semana abaixo de cada nÃºmero
     * @param {string} elementId - ID do elemento do grÃ¡fico
     * @param {Array} diasSemana - Array com os dias da semana correspondentes
     */
    function adicionarLabelsCustomizados(elementId, diasSemana) {
        try {
            const chartContainer = document.querySelector(`#${elementId}`);
            if (!chartContainer) return;

            // Remover labels customizados existentes
            const existingLabels = chartContainer.querySelectorAll('.custom-day-label');
            existingLabels.forEach(label => label.remove());

            // Encontrar os labels do eixo X
            const xAxisLabels = chartContainer.querySelectorAll('.apexcharts-xaxis-texts-g text');
            
            xAxisLabels.forEach((label, index) => {
                if (index < diasSemana.length && diasSemana[index]) {
                    const rect = label.getBoundingClientRect();
                    const containerRect = chartContainer.getBoundingClientRect();                    // Calcular posiÃ§Ã£o relativa ao container
                    const left = rect.left - containerRect.left + (rect.width / 2);
                    const top = rect.bottom - containerRect.top + 6; // Reduzido de 15px para 8px para aproximar data e dia
                    
                    // Criar elemento para o dia da semana
                    const dayLabel = document.createElement('div');
                    dayLabel.className = 'custom-day-label';
                    dayLabel.textContent = diasSemana[index];
                    dayLabel.style.cssText = `
                        position: absolute;
                        left: ${left}px;
                        top: ${top}px;
                        transform: translateX(-50%);
                        font-size: 11px; // Aumentado de 9px para 11px para melhor legibilidade
                        color: #666;
                        font-weight: normal;
                        text-align: center;
                        pointer-events: none;
                        z-index: 10;
                    `;
                    
                    chartContainer.style.position = 'relative';
                    chartContainer.appendChild(dayLabel);
                }
            });
            
            debugLog(`âœ… Labels customizados adicionados para ${elementId}`, diasSemana);
        } catch (error) {
            console.error(`âŒ Erro ao adicionar labels customizados para ${elementId}:`, error);
        }
    }

    /**
     * VerificaÃ§Ã£o de dependÃªncias - ApexCharts deve estar disponÃ­vel
     * Garante que a biblioteca foi carregada antes de prosseguir
     * @function checkDependencies
     */
    if (typeof ApexCharts === 'undefined') {
        console.error('ApexCharts nÃ£o foi carregado! Verifique os CDNs.');
        return;
    }

    /**
     * ConfiguraÃ§Ãµes de cores padronizadas do sistema
     * MantÃ©m consistÃªncia visual em todos os grÃ¡ficos
     * @constant {Object} CORES_SISTEMA
     * @property {string} pactuado - Cor azul para valores planejados
     * @property {string} agendado - Cor azul escuro para agendamentos
     * @property {string} realizado - Cor laranja para valores executados
     * @property {Object} progresso - ConfiguraÃ§Ãµes de cores para gauge
     */
    const CORES_SISTEMA = {
        pactuado: '#0d6efd',    // Azul - Valores planejados
        agendado: '#1e3a8a',    // Azul escuro - Agendamentos  
        realizado: '#fd7e14',   // Laranja - Valores executados
        progresso: {
            fill: '#fd7e14',    // Laranja para gauge
            empty: '#e0e0e0'    // Cinza claro para fundo
        }
    };    /**
     * ConfiguraÃ§Ãµes globais do ApexCharts otimizadas para performance mÃ¡xima
     * Aplicadas a todos os grÃ¡ficos para consistÃªncia e velocidade
     * @constant {Object} CONFIGURACOES_GLOBAIS
     * @property {Object} chart - ConfiguraÃ§Ãµes gerais do grÃ¡fico
     * @property {Object} legend - ConfiguraÃ§Ãµes da legenda
     * @property {Object} grid - ConfiguraÃ§Ãµes da grade
     * @property {Object} tooltip - ConfiguraÃ§Ãµes dos tooltips
     */
    const CONFIGURACOES_GLOBAIS = {
        chart: {
            fontFamily: 'Arial, sans-serif',
            toolbar: {
                show: false // Remove toolbar para interface mais limpa
            },
            animations: {
                enabled: !window.matchMedia('(prefers-reduced-motion: reduce)').matches, // Respeita preferÃªncias de acessibilidade
                easing: 'easeinout',
                speed: 400, // Reduzido de 600ms para 400ms para melhor performance
                dynamicAnimation: {
                    enabled: false // Desabilitar animaÃ§Ãµes dinÃ¢micas para melhor performance
                }
            },
            redrawOnParentResize: true,
            redrawOnWindowResize: false, // Desabilitar auto-resize, usar debouncing manual
            // OtimizaÃ§Ãµes adicionais de performance
            parentHeightOffset: 0,
            offsetX: 0,
            offsetY: 0,
            zoom: {
                enabled: false // Desabilitar zoom para melhor performance
            },
            background: 'transparent'
        },        legend: {
            position: 'top',
            horizontalAlign: 'center',
            floating: false,
            offsetY: -5, // Reduzido de -10 para -5 para menos espaÃ§o
            offsetX: 0,
            markers: {
                width: 12,
                height: 12,
                strokeWidth: 0,
                radius: 2
            },
            itemMargin: {
                horizontal: 15,
                vertical: 5 // Reduzido de 8 para 5 para compactar verticalmente
            },
            fontSize: '11px',
            fontWeight: 500
        },
        grid: {
            borderColor: 'rgba(0, 0, 0, 0.05)',
            strokeDashArray: 0,
            xaxis: {
                lines: {
                    show: false
                }
            },
            yaxis: {
                lines: {
                    show: true
                }
            },            padding: {
                top: 20,    // Reduzido de 40 para 20 para menos espaÃ§o entre legenda e grÃ¡fico
                bottom: 40,  // Aumentado de 25 para 40 para dar mais espaÃ§o aos labels dos dias da semana
                left: 10,
                right: 10
            }
        },
        tooltip: {
            theme: 'light',
            style: {
                fontSize: '12px'
            },
            // OtimizaÃ§Ãµes de performance para tooltips
            enabled: true,
            shared: false,
            intersect: true
        },
        // ConfiguraÃ§Ãµes globais de performance
        states: {
            hover: {
                filter: {
                    type: 'none' // Desabilitar filtros de hover para melhor performance
                }
            }
        }
    };

    /**
     * InicializaÃ§Ã£o condicional dos grÃ¡ficos
     * Verifica se dados estÃ£o disponÃ­veis antes de prosseguir
     * @function initializeCharts
     */
    if (window.dadosGraficos) {
        debugLog('ðŸ“Š Dados recebidos para grÃ¡ficos:', window.dadosGraficos);
        
        // Implementar lazy loading com IntersectionObserver para performance
        initializeLazyCharts();
    } else {
        debugLog('â³ Aguardando dados dos grÃ¡ficos...');
    }

    /**
     * Inicializa carregamento lazy dos grÃ¡ficos
     * Usa IntersectionObserver para carregar grÃ¡ficos apenas quando visÃ­veis
     * @function initializeLazyCharts
     */
    function initializeLazyCharts() {
        const chartElements = document.querySelectorAll('[id^="grafico"], [id^="gauge"]');
        
        if ('IntersectionObserver' in window) {
            const chartObserver = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const elementId = entry.target.id;
                        loadChartForElement(elementId);
                        chartObserver.unobserve(entry.target);
                    }
                });
            }, {
                threshold: 0.1,
                rootMargin: '50px'
            });

            chartElements.forEach(element => {
                chartObserver.observe(element);
            });
            
            debugLog('âœ… Lazy loading configurado para', chartElements.length, 'grÃ¡ficos');
        } else {
            // Fallback para navegadores sem IntersectionObserver
            chartElements.forEach(element => {
                loadChartForElement(element.id);
            });
        }
    }

    /**
     * Carrega grÃ¡fico para elemento especÃ­fico
     * Identifica o tipo de grÃ¡fico e chama a funÃ§Ã£o apropriada
     * @function loadChartForElement
     * @param {string} elementId - ID do elemento HTML onde renderizar o grÃ¡fico
     */
    function loadChartForElement(elementId) {
        Object.values(window.dadosGraficos).forEach(function(dados, index) {
            const graficoId = `grafico${dados.id}`;
            const gaugeId = `gauge${dados.id}`;
            
            if (elementId === graficoId && dados.dadosDiarios) {
                debugLog(`âœ… Criando grÃ¡fico de barras ApexCharts para ${graficoId}`);
                criarGraficoBarrasApex(dados, graficoId);
            }
            
            if (elementId === gaugeId) {
                debugLog(`âœ… Criando gauge ApexCharts para ${gaugeId}`);
                criarGaugeApex(dados, gaugeId);
            }
        });
    }

    /**
     * Cria um grÃ¡fico de barras usando ApexCharts
     * FunÃ§Ã£o principal para renderizaÃ§Ã£o de grÃ¡ficos de coluna/barras
     * 
     * @function criarGraficoBarrasApex
     * @param {Object} dados - Dados do serviÃ§o contendo informaÃ§Ãµes diÃ¡rias
     * @param {string} elementId - ID do elemento canvas onde renderizar
     * @description Processa dados diÃ¡rios e cria grÃ¡fico com trÃªs sÃ©ries:
     *              - Pactuado (valores planejados)
     *              - Agendado (agendamentos realizados)
     *              - Realizado (procedimentos executados)
     */
    function criarGraficoBarrasApex(dados, elementId) {
        PerformanceMonitor.start(`chart_${elementId}`);
        
        try {            /**
             * PreparaÃ§Ã£o e validaÃ§Ã£o dos dados de entrada
             * Garante que os dados estÃ£o no formato correto
             * @type {Array} dadosDiarios - Array com dados diÃ¡rios do serviÃ§o             * @type {Array} categorias - Array com rÃ³tulos dos dias para o eixo X (apenas nÃºmeros)
             * @type {Array} diasSemana - Array com dias da semana para dataLabels customizados
             */
            const dadosDiarios = dados.dadosDiarios || [];
            // Criar categorias apenas com nÃºmeros dos dias para o eixo X
            const categorias = dadosDiarios.map(d => d.dia);
            
            // Separar dados para dataLabels customizados de dias da semana
            const diasSemana = dadosDiarios.map(d => d.dia_semana || '');
            
            /**
             * ConfiguraÃ§Ã£o das sÃ©ries de dados para o grÃ¡fico
             * Cada sÃ©rie representa um tipo de informaÃ§Ã£o (Pactuado, Agendado, Realizado)
             * @type {Array} seriesDados - Array de objetos com dados das sÃ©ries
             */
            const seriesDados = [
                {
                    name: 'Pactuado',
                    data: dadosDiarios.map(d => parseInt(d.pactuado) || 0),
                    color: CORES_SISTEMA.pactuado
                },
                {
                    name: 'Agendado', 
                    data: dadosDiarios.map(d => parseInt(d.agendado) || 0),
                    color: CORES_SISTEMA.agendado
                },
                {
                    name: 'Realizado',
                    data: dadosDiarios.map(d => parseInt(d.realizado) || 0),
                    color: CORES_SISTEMA.realizado
                }
            ];            /**
             * CÃ¡lculo do valor mÃ¡ximo para otimizaÃ§Ã£o do espaÃ§amento
             * Adiciona margem superior para melhor visualizaÃ§Ã£o
             * @type {Array} todosValores - Todos os valores das sÃ©ries combinados
             * @type {number} valorMaximo - Maior valor encontrado
             * @type {number} maxComEspaco - Valor mÃ¡ximo com margem adicional
             */
            const todosValores = seriesDados.flatMap(serie => serie.data);
            const valorMaximo = Math.max(...todosValores);
            const maxComEspaco = valorMaximo + Math.ceil(valorMaximo * 0.1); // +10% do valor mÃ¡ximo (padrÃ£o ApexCharts)

            const opcoes = {
                ...CONFIGURACOES_GLOBAIS,                chart: {
                    ...CONFIGURACOES_GLOBAIS.chart,
                    type: 'bar',
                    height: 380, // Aumentado de 350 para 380 para aproveitar o espaÃ§o economizado
                    id: elementId,
                    // OtimizaÃ§Ãµes de performance mÃ¡ximas
                    parentHeightOffset: 0,
                    sparkline: {
                        enabled: false
                    },
                    group: 'charts' // Agrupar para melhor gerenciamento
                },
                series: seriesDados,                plotOptions: {
                    bar: {
                        horizontal: false,
                        columnWidth: '75%',
                        borderRadius: 0, // Bordas quadradas (removido arredondamento)
                        dataLabels: {
                            position: 'top'
                        }
                    }
                },                dataLabels: {
                    enabled: true,
                    offsetY: -20, // Aumentado de -15 para -20 para ainda mais espaÃ§o entre barras e nÃºmeros
                    style: {
                        fontSize: '8px', // Reduzido de 11px para 10px para evitar sobreposiÃ§Ã£o
                        fontWeight: 'normal', // Mudado de 'bold' para 'normal' para nÃºmeros nÃ£o em negrito
                        colors: ['#333']
                    },
                    textAnchor: 'middle',
                    distributed: false,
                    formatter: function(value) {
                        return value > 0 ? value : '';
                    }
                },
                xaxis: {
                    categories: categorias,
                    labels: {
                        style: {
                            fontSize: '10px'
                        },
                        maxHeight: 100,  // Aumentado de 80 para 100 para garantir espaÃ§o para labels multi-linha
                        trim: false,
                        rotate: 0, // ForÃ§ar rotaÃ§Ã£o 0 para melhor performance
                        formatter: function(value, timestamp, opts) {
                            // Obter Ã­ndice do valor atual
                            const index = opts ? opts.dataPointIndex : categorias.indexOf(String(value));
                            const diaSemana = diasSemana[index] || '';
                            
                            // Retornar com quebra de linha usando \n
                            return `${value}\n${diaSemana}`;
                        },
                        // ConfiguraÃ§Ãµes especÃ­ficas para multi-linha
                        offsetY: 0,
                        hideOverlappingLabels: false
                    },
                    axisBorder: {
                        show: false
                    },
                    axisTicks: {
                        show: false
                    },
                    // ConfiguraÃ§Ã£o adicional para garantir espaÃ§o vertical
                    title: {
                        offsetY: 10
                    }
                },
                yaxis: {
                    min: 0,
                    max: maxComEspaco,
                    tickAmount: 5,  // PadrÃ£o ApexCharts com menos linhas
                    labels: {
                        style: {
                            fontSize: '10px'
                        },
                        formatter: function(value) {
                            return Number.isInteger(value) ? value : '';
                        }
                    },
                    forceNiceScale: false // Desabilitar para melhor performance
                },
                colors: [CORES_SISTEMA.pactuado, CORES_SISTEMA.agendado, CORES_SISTEMA.realizado],
                tooltip: {
                    ...CONFIGURACOES_GLOBAIS.tooltip,
                    y: {
                        formatter: function(value) {
                            return value + ' procedimentos';
                        }
                    }
                },
                // OtimizaÃ§Ãµes especÃ­ficas para barras
                fill: {
                    opacity: 1
                },
                stroke: {
                    show: false // Desabilitar bordas para melhor performance
                }
            };            /**
             * Criar e renderizar o grÃ¡fico de barras usando chart pooling
             * @type {ApexCharts} chart - InstÃ¢ncia do grÃ¡fico ApexCharts
             */
            const chart = ChartPool.get('bar', elementId, opcoes);            chart.render().then(() => {
                // Adicionar labels customizados para dias da semana apÃ³s a renderizaÃ§Ã£o
                setTimeout(() => {
                    adicionarLabelsCustomizados(elementId, diasSemana);
                }, 100);
                
                PerformanceMonitor.end(`chart_${elementId}`);
                debugLog(`âœ… GrÃ¡fico de barras ApexCharts criado para ${elementId}`);
            }).catch(error => {
                PerformanceMonitor.end(`chart_${elementId}`);
                console.error(`âŒ Erro ao renderizar grÃ¡fico para ${elementId}:`, error);
            });

        } catch (error) {
            PerformanceMonitor.end(`chart_${elementId}`);
            console.error(`âŒ Erro ao criar grÃ¡fico ApexCharts para ${elementId}:`, error);
        }
    }

    /**
     * Cria um grÃ¡fico de linha usando ApexCharts
     * FunÃ§Ã£o para renderizaÃ§Ã£o de grÃ¡ficos de linha com mÃºltiplas sÃ©ries
     * 
     * @function criarGraficoLinha
     * @param {Object} dados - Dados do serviÃ§o contendo informaÃ§Ãµes diÃ¡rias
     * @param {string} elementId - ID do elemento onde renderizar o grÃ¡fico
     * @description Processa dados diÃ¡rios e cria grÃ¡fico de linha com trÃªs sÃ©ries:
     *              - Pactuado (valores planejados)
     *              - Agendado (agendamentos realizados) 
     *              - Realizado (procedimentos executados)
     */
    function criarGraficoLinha(dados, elementId) {
        PerformanceMonitor.start(`line_chart_${elementId}`);
          try {            /**
             * PreparaÃ§Ã£o dos dados para grÃ¡fico de linha
             * @type {Array} dadosDiarios - Dados diÃ¡rios do serviÃ§o
             * @type {Array} categorias - Categorias para o eixo X (apenas nÃºmeros dos dias)
             * @type {Array} diasSemana - Array com dias da semana para dataLabels customizados
             */
            const dadosDiarios = dados.dadosDiarios || [];
            // Criar categorias apenas com nÃºmeros dos dias para o eixo X
            const categorias = dadosDiarios.map(d => d.dia);
            
            // Separar dados para dataLabels customizados de dias da semana
            const diasSemana = dadosDiarios.map(d => d.dia_semana || '');
            
            /**
             * ConfiguraÃ§Ã£o das sÃ©ries para grÃ¡fico de linha
             * @type {Array} seriesDados - SÃ©ries de dados para o grÃ¡fico
             */
            const seriesDados = [
                {
                    name: 'Pactuado',
                    data: dadosDiarios.map(d => parseInt(d.pactuado) || 0),
                    color: CORES_SISTEMA.pactuado
                },
                {
                    name: 'Agendado',
                    data: dadosDiarios.map(d => parseInt(d.agendado) || 0),
                    color: CORES_SISTEMA.agendado
                },
                {
                    name: 'Realizado',
                    data: dadosDiarios.map(d => parseInt(d.realizado) || 0),
                    color: CORES_SISTEMA.realizado
                }
            ];

            /**
             * ConfiguraÃ§Ãµes especÃ­ficas do grÃ¡fico de linha
             * @type {Object} opcoes - ConfiguraÃ§Ã£o completa para grÃ¡fico de linha
             */
            const opcoes = {
                ...CONFIGURACOES_GLOBAIS,                chart: {
                    ...CONFIGURACOES_GLOBAIS.chart,
                    type: 'line',
                    height: 380, // Aumentado de 350 para 380 para aproveitar o espaÃ§o economizado
                    id: elementId
                },
                series: seriesDados,
                stroke: {
                    width: 3,
                    curve: 'smooth'
                },
                markers: {
                    size: 4,
                    hover: {
                        size: 6
                    }
                },                xaxis: {
                    categories: categorias,
                    labels: {
                        style: {
                            fontSize: '10px'
                        },
                        maxHeight: 100,  // Aumentado de 80 para 100 para garantir espaÃ§o para labels multi-linha
                        trim: false,
                        rotate: 0, // ForÃ§ar rotaÃ§Ã£o 0 para que labels fiquem verticais
                        formatter: function(value, timestamp, opts) {
                            // Obter Ã­ndice do valor atual
                            const index = opts ? opts.dataPointIndex : categorias.indexOf(String(value));
                            const diaSemana = diasSemana[index] || '';
                            
                            // Retornar com quebra de linha usando \n
                            return `${value}\n${diaSemana}`;
                        },
                        // ConfiguraÃ§Ãµes especÃ­ficas para multi-linha
                        offsetY: 0,
                        hideOverlappingLabels: false
                    }
                },yaxis: {
                    tickAmount: 6,  // Reduzir nÃºmero de linhas do grid para padrÃ£o ApexCharts
                    labels: {
                        style: {
                            fontSize: '10px'
                        },
                        formatter: function(value) {
                            return Number.isInteger(value) ? value : '';
                        }
                    }
                },
                colors: [CORES_SISTEMA.pactuado, CORES_SISTEMA.agendado, CORES_SISTEMA.realizado],
                tooltip: {
                    ...CONFIGURACOES_GLOBAIS.tooltip,
                    y: {
                        formatter: function(value) {
                            return value + ' procedimentos';
                        }
                    }
                }
            };            /**
             * Criar e renderizar o grÃ¡fico de linha
             * @type {ApexCharts} lineChart - InstÃ¢ncia do grÃ¡fico de linha
             */
            const lineChart = new ApexCharts(document.querySelector(`#${elementId}`), opcoes);
            lineChart.render().then(() => {
                // Adicionar labels customizados para dias da semana apÃ³s a renderizaÃ§Ã£o
                setTimeout(() => {
                    adicionarLabelsCustomizados(elementId, diasSemana);
                }, 100);
                
                PerformanceMonitor.end(`line_chart_${elementId}`);
                debugLog(`âœ… GrÃ¡fico de linha ApexCharts criado para ${elementId}`);
            });

        } catch (error) {
            PerformanceMonitor.end(`line_chart_${elementId}`);
            console.error(`âŒ Erro ao criar grÃ¡fico de linha para ${elementId}:`, error);
        }    }    /**
     * Adiciona linha de referÃªncia visual para valor pactuado no gauge
     * Desenha uma linha SVG customizada para mostrar onde o pactuado se posiciona
     * @function adicionarLinhaReferenciaPactuado
     * @param {string} elementId - ID do elemento do gauge
     * @param {number} progressoPactuado - Percentual do pactuado para posicionamento
     */
    function adicionarLinhaReferenciaPactuado(elementId, progressoPactuado) {
        try {
            const gaugeContainer = document.querySelector(`#${elementId}`);
            if (!gaugeContainer) return;

            // Remover linha de referÃªncia existente se houver
            const existingLine = gaugeContainer.querySelector('.pactuado-reference-line');
            if (existingLine) {
                existingLine.remove();
            }

            // Encontrar o SVG do gauge
            const svg = gaugeContainer.querySelector('svg');
            if (!svg) return;

            // Encontrar o path do gauge existente para obter dimensÃµes reais
            const gaugePath = svg.querySelector('.apexcharts-radialbar-track') || 
                            svg.querySelector('.apexcharts-radialbar-area') ||
                            svg.querySelector('path[stroke]');
            
            if (!gaugePath) {
                debugLog('âŒ Path do gauge nÃ£o encontrado');
                return;
            }

            // Obter dimensÃµes do SVG
            const svgRect = svg.getBoundingClientRect();
            const svgWidth = svgRect.width;
            const svgHeight = svgRect.height;
            
            // Centro do gauge (ApexCharts coloca o gauge no centro do SVG)
            const centerX = svgWidth / 2;
            const centerY = svgHeight / 2;
            
            // Para gauge semicircular ApexCharts: startAngle: -90, endAngle: 90 (180Â° total)
            // Calcular Ã¢ngulo baseado no percentual do pactuado
            const startAngle = -90; // Ã‚ngulo inicial em graus
            const endAngle = 90;    // Ã‚ngulo final em graus
            const totalAngle = endAngle - startAngle; // 180Â°
            
            const targetAngle = startAngle + (progressoPactuado / 100) * totalAngle;
            const angleRad = (targetAngle * Math.PI) / 180;
            
            // Calcular raios baseado no tamanho real do gauge
            // Gauge padrÃ£o ApexCharts usa aproximadamente 40% da Ã¡rea disponÃ­vel
            const gaugeRadius = Math.min(svgWidth, svgHeight) * 0.35; // Raio externo
            const innerRadius = gaugeRadius * 0.4; // Hollow size 40%
            const outerRadius = gaugeRadius * 0.95; // Raio externo (pouco menor para ficar dentro)
            
            // Calcular posiÃ§Ãµes da linha
            const x1 = centerX + innerRadius * Math.cos(angleRad);
            const y1 = centerY + innerRadius * Math.sin(angleRad);
            const x2 = centerX + outerRadius * Math.cos(angleRad);
            const y2 = centerY + outerRadius * Math.sin(angleRad);

            // Criar elemento de linha SVG
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', x1);
            line.setAttribute('y1', y1);
            line.setAttribute('x2', x2);
            line.setAttribute('y2', y2);
            line.setAttribute('stroke', '#0d6efd'); // Azul para pactuado
            line.setAttribute('stroke-width', '4'); // Aumentado para melhor visibilidade
            line.setAttribute('stroke-linecap', 'round'); // Pontas arredondadas para melhor visual
            line.setAttribute('class', 'pactuado-reference-line');
            
            // Adicionar linha ao SVG (inserir antes dos textos para ficar atrÃ¡s)
            const firstText = svg.querySelector('text');
            if (firstText) {
                svg.insertBefore(line, firstText);
            } else {
                svg.appendChild(line);
            }
            
            debugLog(`âœ… Linha de referÃªncia pactuado: ${progressoPactuado}% - Ã‚ngulo: ${targetAngle.toFixed(1)}Â° - Coords: (${x1.toFixed(1)},${y1.toFixed(1)}) -> (${x2.toFixed(1)},${y2.toFixed(1)})`);
            
        } catch (error) {
            console.error(`âŒ Erro ao adicionar linha de referÃªncia para ${elementId}:`, error);
        }
    }

    /**
     * Cria um gauge (grÃ¡fico radial) usando ApexCharts
     * 
     * @function criarGaugeApex
     * @param {Object} dados - Dados do serviÃ§o
     * @param {string} elementId - ID do elemento
     */    function criarGaugeApex(dados, elementId) {
        PerformanceMonitor.start(`gauge_${elementId}`);
        
        try {
            /**
             * Calcular progresso baseado nos dados e total pactuado
             * @type {number} totalExecutados - Total de procedimentos executados
             * @type {number} metaPdt - Meta de produtividade
             * @type {number} totalPactuado - Total pactuado (soma dos dados diÃ¡rios)
             * @type {number} progresso - Percentual de progresso calculado
             * @type {number} progressoPactuado - Percentual do pactuado em relaÃ§Ã£o Ã  meta
             */
            const totalExecutados = parseInt(dados.total_executados) || 0;
            const metaPdt = parseInt(dados.meta_pdt) || 0;
            const progresso = metaPdt > 0 ? Math.min(100, Math.round((totalExecutados / metaPdt) * 100)) : 0;
            
            // Calcular total pactuado dos dados diÃ¡rios
            let totalPactuado = 0;
            if (dados.dadosDiarios && Array.isArray(dados.dadosDiarios)) {
                totalPactuado = dados.dadosDiarios.reduce((sum, dia) => {
                    return sum + (parseInt(dia.pactuado) || 0);
                }, 0);
            }
            const progressoPactuado = metaPdt > 0 ? Math.min(100, Math.round((totalPactuado / metaPdt) * 100)) : 0;

            /**
             * Usar cor do grupo se disponÃ­vel
             * @type {string} corProgresso - Cor para o gauge principal (realizado)
             */
            let corProgresso = CORES_SISTEMA.progresso.fill;
            if (dados.grupo_cor && dados.grupo_cor !== '#6B7280') {
                corProgresso = dados.grupo_cor;
            }

            /**
             * ConfiguraÃ§Ãµes do gauge radial com indicador de pactuado
             * @type {Object} opcoes - ConfiguraÃ§Ã£o completa do gauge
             */
            const opcoes = {
                chart: {
                    type: 'radialBar',
                    height: 200,
                    id: `${elementId}-gauge`,
                    // OtimizaÃ§Ãµes especÃ­ficas para gauge
                    sparkline: {
                        enabled: true // Gauges se beneficiam do sparkline
                    },
                    animations: {
                        enabled: CONFIGURACOES_GLOBAIS.chart.animations.enabled,
                        speed: 300, // Mais rÃ¡pido para gauges
                        animateGradually: {
                            enabled: false // Desabilitar animaÃ§Ã£o gradual para melhor performance
                        }
                    }                },
                series: [progresso], // Apenas uma sÃ©rie: realizado
                plotOptions: {
                    radialBar: {
                        hollow: {
                            size: '40%'  // Reduzido de 60% para 40% para gauge muito mais grosso e proeminente
                        },
                        startAngle: -90,
                        endAngle: 90,
                        track: {
                            background: CORES_SISTEMA.progresso.empty,
                            strokeWidth: '100%',
                            margin: 8  // Aumentado de 5 para 8 para melhor espaÃ§amento
                        },
                        dataLabels: {
                            show: false
                        }
                    }                },
                colors: [corProgresso], // Cor principal para realizado
                stroke: {
                    lineCap: 'butt' // Bordas quadradas no gauge (removido arredondamento)
                },
                labels: ['Realizado']
            };

            /**
             * Criar e renderizar o gauge usando chart pooling
             * @type {ApexCharts} gauge - InstÃ¢ncia do gauge
             */            const gauge = ChartPool.get('gauge', elementId, opcoes);
            gauge.render().then(() => {
                // Adicionar linha de referÃªncia do pactuado apÃ³s renderizaÃ§Ã£o
                setTimeout(() => {
                    adicionarLinhaReferenciaPactuado(elementId, progressoPactuado);
                }, 200);
                
                PerformanceMonitor.end(`gauge_${elementId}`);
                debugLog(`âœ… Gauge ApexCharts criado para ${elementId} - ${progresso}% (Pactuado: ${progressoPactuado}%)`);
            }).catch(error => {
                PerformanceMonitor.end(`gauge_${elementId}`);
                console.error(`âŒ Erro ao renderizar gauge para ${elementId}:`, error);
            });

        } catch (error) {
            PerformanceMonitor.end(`gauge_${elementId}`);
            console.error(`âŒ Erro ao criar gauge ApexCharts para ${elementId}:`, error);
        }
    }

    /**
     * Sistema de cache para dados dos grÃ¡ficos
     * @constant {Object} CACHE_CONFIG - ConfiguraÃ§Ãµes do sistema de cache
     */
    const CACHE_CONFIG = {
        enabled: true,
        duration: 5 * 60 * 1000, // 5 minutos em millisegundos
        keyPrefix: 'rtp_chart_data_'
    };

    /**
     * Cache manager para dados dos grÃ¡ficos
     * Gerencia armazenamento local de dados para melhor performance
     * @namespace CacheManager
     */
    const CacheManager = {
        /**
         * Salva dados no cache local
         * @function set
         * @param {string} key - Chave identificadora
         * @param {*} data - Dados a serem salvos
         * @returns {boolean} - Sucesso da operaÃ§Ã£o
         */
        set: function(key, data) {
            if (!CACHE_CONFIG.enabled || !window.localStorage) return false;
            
            try {
                const cacheData = {
                    data: data,
                    timestamp: Date.now(),
                    expires: Date.now() + CACHE_CONFIG.duration
                };
                
                localStorage.setItem(CACHE_CONFIG.keyPrefix + key, JSON.stringify(cacheData));
                debugLog('ðŸ’¾ Dados salvos no cache:', key);
                return true;
            } catch (error) {
                console.warn('Erro ao salvar no cache:', error);
                return false;
            }
        },

        /**
         * Recupera dados do cache local
         * @function get
         * @param {string} key - Chave identificadora
         * @returns {*|null} - Dados recuperados ou null se nÃ£o encontrado/expirado
         */
        get: function(key) {
            if (!CACHE_CONFIG.enabled || !window.localStorage) return null;
            
            try {
                const cached = localStorage.getItem(CACHE_CONFIG.keyPrefix + key);
                if (!cached) return null;
                
                const cacheData = JSON.parse(cached);
                
                // Verificar se o cache expirou
                if (Date.now() > cacheData.expires) {
                    this.remove(key);
                    debugLog('â° Cache expirado removido:', key);
                    return null;
                }
                
                debugLog('âœ… Dados recuperados do cache:', key);
                return cacheData.data;
            } catch (error) {
                console.warn('Erro ao ler do cache:', error);
                this.remove(key);
                return null;
            }
        },

        /**
         * Remove item especÃ­fico do cache
         * @function remove
         * @param {string} key - Chave do item a ser removido
         */
        remove: function(key) {
            if (window.localStorage) {
                localStorage.removeItem(CACHE_CONFIG.keyPrefix + key);
            }
        },

        /**
         * Limpa todo o cache do sistema
         * @function clear
         */
        clear: function() {
            if (!window.localStorage) return;
            
            const keys = Object.keys(localStorage);
            keys.forEach(key => {
                if (key.startsWith(CACHE_CONFIG.keyPrefix)) {
                    localStorage.removeItem(key);
                }
            });
            debugLog('ðŸ—‘ï¸ Cache limpo');
        },

        /**
         * Gera chave Ãºnica para cache baseada em parÃ¢metros
         * @function generateKey
         * @param {string} unidade - Identificador da unidade
         * @param {Object} periodo - Objeto com inÃ­cio e fim do perÃ­odo
         * @returns {string} - Chave Ãºnica gerada
         */
        generateKey: function(unidade, periodo) {
            return `${unidade}_${periodo.inicio}_${periodo.fim}`;
        }
    };

    // Exportar cache manager para uso global
    window.ChartCache = CacheManager;    /**
     * FunÃ§Ã£o para redimensionar grÃ¡ficos com debouncing otimizado
     * Evita mÃºltiplas chamadas durante redimensionamento da janela
     * @function redimensionarGraficos
     */
    let resizeTimeout;
    window.redimensionarGraficos = function() {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
            if (window.ApexCharts) {
                PerformanceMonitor.start('resize_all_charts');
                window.ApexCharts.exec('*', 'windowResize');
                PerformanceMonitor.end('resize_all_charts');
                debugLog('ðŸ”„ GrÃ¡ficos redimensionados');
            }
        }, 100); // Debounce reduzido para 100ms para melhor responsividade
    };

    // Event listener para resize com throttling adicional
    let lastResize = 0;
    window.addEventListener('resize', function() {
        const now = Date.now();
        if (now - lastResize > 50) { // Throttling de 50ms
            lastResize = now;
            window.redimensionarGraficos();
        }
    });

    /**
     * Debug: InformaÃ§Ãµes sobre grupos (se disponÃ­vel)
     * Exibe informaÃ§Ãµes dos grupos de serviÃ§os no console (apenas desenvolvimento)
     */
    if (window.gruposInfo) {
        debugLog('ðŸ“‹ InformaÃ§Ãµes dos grupos:', window.gruposInfo);
        if (DEBUG_MODE) {
            window.gruposInfo.forEach(grupo => {
                console.log(`ðŸ¥ Grupo ${grupo.id}: ${grupo.nome} (${grupo.servicos_count} serviÃ§os) - Cor: ${grupo.cor}`);
            });
        }
    }

    debugLog('ðŸŽ¯ Sistema ApexCharts inicializado com sucesso!');    /**
     * Sistema de monitoramento de performance em tempo real
     * Permite medir tempos de execuÃ§Ã£o de operaÃ§Ãµes crÃ­ticas
     * @namespace PerformanceMonitor
     */
    const PerformanceMonitor = {
        /**
         * Armazena os timers ativos
         * @type {Object} timers
         */
        timers: {},
        
        /**
         * Inicia cronÃ´metro para uma operaÃ§Ã£o
         * @function start
         * @param {string} name - Nome identificador da operaÃ§Ã£o
         */
        start: function(name) {
            this.timers[name] = performance.now();
        },
        
        /**
         * Finaliza cronÃ´metro e calcula duraÃ§Ã£o
         * @function end
         * @param {string} name - Nome identificador da operaÃ§Ã£o
         * @returns {number|null} DuraÃ§Ã£o em milissegundos ou null se nÃ£o encontrado
         */
        end: function(name) {
            if (!this.timers[name]) return null;
            
            const duration = performance.now() - this.timers[name];
            delete this.timers[name];
            
            debugLog(`â±ï¸ Performance ${name}:`, `${duration.toFixed(2)}ms`);
            
            // Alertar se performance estiver ruim (>150ms) - limite reduzido para mais rigor
            if (duration > 150) {
                console.warn(`âš ï¸ Performance lenta em ${name}: ${duration.toFixed(2)}ms`);
            }
            
            return duration;
        }
    };

    /**
     * Sistema de Chart Pooling para reutilizar instÃ¢ncias
     * Reduz criaÃ§Ã£o/destruiÃ§Ã£o de objetos para melhor performance
     * @namespace ChartPool
     */
    const ChartPool = {
        /**
         * Pool de grÃ¡ficos disponÃ­veis para reutilizaÃ§Ã£o
         * @type {Object} pools
         */
        pools: {
            bar: [],
            line: [],
            gauge: []
        },
        
        /**
         * Contador de uso para estatÃ­sticas
         * @type {Object} usage
         */
        usage: {
            created: 0,
            reused: 0
        },
        
        /**
         * ObtÃ©m grÃ¡fico do pool ou cria novo se necessÃ¡rio
         * @function get
         * @param {string} type - Tipo do grÃ¡fico (bar, line, gauge)
         * @param {string} elementId - ID do elemento
         * @param {Object} options - ConfiguraÃ§Ãµes do grÃ¡fico
         * @returns {ApexCharts} InstÃ¢ncia do grÃ¡fico
         */
        get: function(type, elementId, options) {
            const pool = this.pools[type];
            
            if (pool && pool.length > 0) {
                const chart = pool.pop();
                chart.updateOptions(options, true, true, false);
                this.usage.reused++;
                debugLog(`â™»ï¸ GrÃ¡fico ${type} reutilizado do pool para ${elementId}`);
                return chart;
            }
            
            // Criar novo grÃ¡fico se nÃ£o hÃ¡ no pool
            const chart = new ApexCharts(document.querySelector(`#${elementId}`), options);
            this.usage.created++;
            debugLog(`ðŸ†• Novo grÃ¡fico ${type} criado para ${elementId}`);
            return chart;
        },
        
        /**
         * Retorna grÃ¡fico para o pool para reutilizaÃ§Ã£o futura
         * @function release
         * @param {string} type - Tipo do grÃ¡fico
         * @param {ApexCharts} chart - InstÃ¢ncia do grÃ¡fico
         */
        release: function(type, chart) {
            if (chart && this.pools[type]) {
                chart.destroy();
                // NÃ£o reutilizar por agora para evitar problemas - apenas contar estatÃ­sticas
                debugLog(`ðŸ”„ GrÃ¡fico ${type} liberado`);
            }
        },
        
        /**
         * Limpa todos os pools
         * @function clear
         */
        clear: function() {
            Object.keys(this.pools).forEach(type => {
                this.pools[type].forEach(chart => chart.destroy());
                this.pools[type] = [];
            });
            debugLog('ðŸ—‘ï¸ Chart pools limpos');
        },
        
        /**
         * Retorna estatÃ­sticas de uso
         * @function getStats
         * @returns {Object} EstatÃ­sticas de uso
         */
        getStats: function() {
            return {
                ...this.usage,
                efficiency: this.usage.reused > 0 ? 
                    (this.usage.reused / (this.usage.created + this.usage.reused) * 100).toFixed(2) + '%' : 
                    '0%'
            };
        }
    };

    /**
     * Alias para compatibilidade com versÃµes anteriores
     * MantÃ©m funcionalidade existente enquanto migra para nova nomenclatura
     * @function criarGraficoColuna
     * @deprecated Use criarGraficoBarrasApex em seu lugar
     */
    window.criarGraficoColuna = criarGraficoBarrasApex;
    
    /**
     * Alias para compatibilidade com versÃµes anteriores
     * MantÃ©m funcionalidade existente para gauge charts
     * @function criarGaugeChart
     * @deprecated Use criarGaugeApex em seu lugar
     */
    window.criarGaugeChart = criarGaugeApex;
      /**
     * Exportar funÃ§Ãµes principais para uso global
     * Permite acesso externo Ã s funcionalidades do sistema
     */
    window.criarGraficoBarrasApex = criarGraficoBarrasApex;
    window.criarGraficoLinha = criarGraficoLinha;
    window.criarGaugeApex = criarGaugeApex;
    window.criarGaugeChart = criarGaugeApex; // Alias adicional
    window.PerformanceMonitor = PerformanceMonitor;
    window.ChartPool = ChartPool;
    
    /**
     * EstatÃ­sticas de performance do sistema
     * @function getPerformanceStats
     * @returns {Object} EstatÃ­sticas completas do sistema
     */
    window.getPerformanceStats = function() {
        return {
            chartPool: ChartPool.getStats(),
            cacheHits: CacheManager.getStats ? CacheManager.getStats() : { hits: 0, misses: 0 },
            memory: {
                used: (performance.memory ? performance.memory.usedJSHeapSize : 0),
                total: (performance.memory ? performance.memory.totalJSHeapSize : 0)
            }
        };
    };
    
    // Log das estatÃ­sticas de inicializaÃ§Ã£o em debug mode
    if (DEBUG_MODE) {
        setTimeout(() => {
            debugLog('ðŸ“Š EstatÃ­sticas de performance:', window.getPerformanceStats());
        }, 2000);
    }
});
